#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.25.1
#  in conjunction with Tcl version 8.6
#    Oct 04, 2019 01:33:05 PM PDT  platform: Windows NT

import sys, os, csv, logging, fiona
import xml.etree.ElementTree as ET
import HAST_Analysis as ha
#import HAST_GUI as hgui
#XML setup
tree = ET.parse('settings.xml')
base = tree.getroot()
"""
for node in tree.find('.//currentrun'):
    node.text = ''
    tree.write('settings.xml')
"""
#Logging setup
LogFileName = tree.find('.//LogFileName').text
Level = tree.find('.//Level').text
#LogFileName = next(next(next(base.iter('data')).iter('Logging')).iter('LogFileName')).text
#Level = next(next(next(base.iter('data')).iter('Logging')).iter('Level')).text
if Level == 'INFO': logging.basicConfig(filename=LogFileName, filemode='w', level=logging.INFO)
else: logging.basicConfig(filename=LogFileName, filemode='w', level=logging.DEBUG)
logging.info(' Logging level set to: '+ str(Level))

#Field alias setup
defaultFields = {(item.tag if item.attrib['required'] != 'yes' else item.tag+'*'):item.text.split(',') for item in tree.find('.//AnalysisFields')}
#defaultFields = {(item.tag if item.attrib['required'] != 'yes' else item.tag+'*'):item.text.split(',') for item in next(base.iter('fields'))}#{item.attributes['name'].value:item.firstChild.data.split(',') for item in items}

#Allowed file types setup
file_types = [('Type '+item,item) for item in tree.find('.//InputFileTypes').text.split(',')]
#file_types = [('Type '+item,item) for item in next(next(base.iter('GeneralSettings')).iter('InputFileTypes')).text.split(',')]

logging.debug(' Field Types: ' + str(file_types))

fields = {'Longitude*':'LongitudeEntry',
    'Latitude*':'LatitudeEntry',
    'SOID*':'SOIDEntry',
    'BuildingArea*':'BuildingAreaEntry',
    'BuildingValue*':'BuildingValueEntry',
    'HUSBT*':'HUSBTEntry',
    'TerrainID*':'TerrainIDEntry',
    'WBID*':'WBIDEntry',
    }

try:
    import Tkinter as tk
    from Tkinter import filedialog
except ImportError:
    import tkinter as tk
    from tkinter import filedialog

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True


def set_Tk_var():
    global FileText
    FileText = tk.StringVar()
    global SelectVar
    SelectVar = tk.StringVar()
    global WindVar
    WindVar = tk.StringVar()

def checkform(button,fields):# Check validity of form entries
    ents = fields
    #root.fields = fields
    #print('fields ',[field.get() for field in fields.values()])
    #root.fields = {key:''for key, value in fields.items()}
    for key, field in ents.items():
        color = "yellow" if '*' not in key else "red"
        ent = field
        value = ent.get().upper()# if type(ent) != str else ent
        if '*' in key: root.valid[key] = False
        if len(root.csvFields) == 0:
            color = None# If no input file is selected there is no coloring.
        elif value != '':
            if value in root.csvFields:
                 root.fields[key] = value
                 color = "green"
                 if '*' in key: root.valid[key] = True
        else:
            for defaultField in list(map(lambda x: x.upper(), defaultFields[key])):
                 if defaultField in root.csvFields:
                      root.fields[key] = root.csvFields[root.csvFields.index(defaultField)]
                      color = "green"
                      if '*' in key: root.valid[key] = True
                      break
        ent.config(background=color)
         
    
    if False in root.valid.values(): button.config(fg='grey',command='')
    else: button.config(fg='black', command=analyze)
    
    root.after(100, checkform,button,fields)
    #root.after(100, checkform(button,fields))#Recheck fields every 0.1 second
    
def browse_button(button,fields):
    print('HAST_support.browse_button')
    logging.info(' HAST_support.browse_button')
    sys.stdout.flush()
    root.csvFields = []
    root.fields = {key:''for key, value in fields.items()}
    root.valid = {}
    
    #print('FILE TYPES',*tuple([('type',item.text) for item in next(base.iter('GeneralSettings')).iter('InputFileTypes')])+("all files","*.*"))
    filename = filedialog.askopenfilename(initialdir = os.path.join(os.path.dirname(os.getcwd()),"input"),title = "Select file",filetypes = file_types)# Gets input csv file from user
    # Gets field names from input csv file and makes a list
    try:
        with open(filename, "r+") as f:
            reader = csv.reader(f)
            root.csvFields = next(reader)
            logging.debug(' File Open: '+filename+' File Fields: '+ str(root.csvFields))
            root.csvFields = list(map(lambda x: x.upper(), root.csvFields))
    except Exception as e:
        logging.debug(' Failed to open input file. Message: '+str(e))
        return
    
    #Save the input file name and path to the Settings.xml - InputFileName (under this node)
    SelectVar.set(filename)
    tree.getroot().find('.//InputFileName').text = filename
    tree.write('settings.xml')
    print(filename,root.csvFields)
    
def WindfieldBrowse():
    print('HAST_support.WindfieldBrowse')
    logging.info(' HAST_support.WindfieldBrowse')
    sys.stdout.flush()
    root.WindfieldCSV = []
    root.WindfieldFields = {key:''for key, value in fields.items()}
    #root.WindfieldValid = {}
    
    #print('FILE TYPES',*tuple([('type',item.text) for item in next(base.iter('GeneralSettings')).iter('InputFileTypes')])+("all files","*.*"))
    filename = filedialog.askopenfilename(initialdir = os.path.join(os.path.dirname(os.getcwd()),"windfield",'probabilistic'),title = "Select file",filetypes = file_types)# Gets input csv file from user
    # Gets field names from input csv file and makes a list
    try:
        with open(filename, "r+") as f:
            reader = csv.reader(f)
            root.WindfieldFields = next(reader)
            logging.debug(' File Open: '+filename+' File Fields: '+ str(root.WindfieldFields))
            root.WindfieldFields = list(map(lambda x: x.upper(), root.WindfieldFields))
    except Exception as e:
        logging.debug(' Failed to open input file. Message: '+str(e))
        return
    
    #Save the input file name and path to the Settings.xml - InputFileName (under this node)
    tree.getroot().find('.//WindFieldDataFile').text = filename
    tree.write('settings.xml')
    WindVar.set(filename)
    #w.WindfieldLabel.config(text = filename)
    print(filename,root.WindfieldFields)

def analyze():
    logging.info(' Running analysis ')
    logging.info(' Input fields: ' + str(root.fields))
    for item in tree.find('.//AnalysisFields'):
        item.attrib['inputFieldName'] = root.fields[item.tag] if item.attrib['required'] == 'no' else root.fields[item.tag+'*']
    tree.getroot().find('.//InputFileFieldMap').text = SelectVar.get()#str(root.fields)
    tree.write('settings.xml')
    ha.HAST_Probabilistic_Analysis()

def start_program():
    import HAST_Analysis_GUI
    HAST_Analysis_GUI.vp_start_gui()

def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top
    root.iconbitmap('../Images/Hu_Symbol.ico')
    root.csvFields = []# Input csv file fields
    root.fields = {key:''for key, value in fields.items()}
    root.valid = {}
    root.WindfieldCSV = []
    root.WindfieldFields = {key:''for key, value in fields.items()}
    #root.WindfieldValid = {}
    
    # Gets the requested values of the height and widht.
    windowWidth = root.winfo_reqwidth()
    windowHeight = root.winfo_reqheight()
     
    # Gets both half the screen width/height and window width/height
    positionRight = int(root.winfo_screenwidth()/2 - windowWidth)
    positionDown = int(root.winfo_screenheight()/2 - windowHeight)
     
    # Positions the window in the center of the page.
    root.geometry("+{}+{}".format(positionRight, positionDown))
    
    root.after(100, checkform,w.Run,{'Longitude*':w.LongitudeEntry,\
    'Latitude*':w.LatitudeEntry,\
    'SOID*':w.SOIDEntry,\
    'BuildingArea*':w.BuildingAreaEntry,\
    'BuildingValue*':w.BuildingValueEntry,\
    'HUSBT*':w.HUSBTEntry,\
    'TerrainID*':w.TerrainIDEntry,\
    'WBID*':w.WBIDEntry})
    
    

def popupmsg(msg, comm):
    popup = tk.Toplevel()
    popup.configure(background="#87CEFA")
    popup.iconbitmap('../Images/Hu_Symbol.ico')
    popup.wm_title("HAST")
    label = tk.Label(popup, text=msg,background="#87CEFA")
    label.pack(fill="x", pady=10)
    parent = tk.Frame(popup)#.configure(background='#97CFFC')
    parent.configure(background="#87CEFA")
    parent.pack()
    B1 = tk.Button(parent, text="Yes", command = comm,background="#87CEFA")
    B1.pack(fill='x', side = 'left', padx=10, pady=10)
    B1.configure(height=1, width=5)
    B2 = tk.Button(parent, text="Cancel", command = popup.destroy,background="#87CEFA")
    B2.pack(fill='x', side = 'left', padx=10)
    B2.configure(height=1, width=5)
    parent.pack(expand=1)
    
    # Gets the requested values of the height and widht.
    windowWidth = popup.winfo_reqwidth()
    windowHeight = popup.winfo_reqheight()
     
    # Gets both half the screen width/height and window width/height
    positionRight = int(popup.winfo_screenwidth()/2 - windowWidth)
    positionDown = int(popup.winfo_screenheight()/2 - windowHeight)
     
    # Positions the window in the center of the page.
    popup.geometry("+{}+{}".format(positionRight, positionDown))
    
    
    popup.mainloop()

def startPreProcess():
    import HAST_PreProcess_GUI_support
    destroy_window()
    HAST_PreProcess_GUI_support.start_program()

def MainScreen():
    popupmsg('Are you sure you want to go to the main screen?', startMainScreen)

def startMainScreen():
    import HAST_Main_GUI_support
    destroy_window()
    HAST_Main_GUI_support.start_program()

def SelectWindfield():
    WindfieldBrowse()

def Exit():
    popupmsg('Are you sure you want to quit?', destroy_window)
    
def destroy_window():
    # Function which closes the window.
    logging.info(' Window Closed')
    global top_level
    """
    for node in tree.find('.//currentrun'):
        node.text = ''
    tree.write('settings.xml')
    """
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    import HAST_Analysis_GUI
    HAST_Analysis_GUI.vp_start_gui()




